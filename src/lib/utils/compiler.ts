import type { Node, Connection, DuckyScript } from "../types/nodes.js";

const ALT_CODE_MAP: Record<string, string> = {
  A: "ALTCHAR 65",
  B: "ALTCHAR 66",
  C: "ALTCHAR 67",
  D: "ALTCHAR 68",
  E: "ALTCHAR 69",
  F: "ALTCHAR 70",
  G: "ALTCHAR 71",
  H: "ALTCHAR 72",
  I: "ALTCHAR 73",
  J: "ALTCHAR 74",
  K: "ALTCHAR 75",
  L: "ALTCHAR 76",
  M: "ALTCHAR 77",
  N: "ALTCHAR 78",
  O: "ALTCHAR 79",
  P: "ALTCHAR 80",
  Q: "ALTCHAR 81",
  R: "ALTCHAR 82",
  S: "ALTCHAR 83",
  T: "ALTCHAR 84",
  U: "ALTCHAR 85",
  V: "ALTCHAR 86",
  W: "ALTCHAR 87",
  X: "ALTCHAR 88",
  Y: "ALTCHAR 89",
  Z: "ALTCHAR 90",

  a: "ALTCHAR 97",
  b: "ALTCHAR 98",
  c: "ALTCHAR 99",
  d: "ALTCHAR 100",
  e: "ALTCHAR 101",
  f: "ALTCHAR 102",
  g: "ALTCHAR 103",
  h: "ALTCHAR 104",
  i: "ALTCHAR 105",
  j: "ALTCHAR 106",
  k: "ALTCHAR 107",
  l: "ALTCHAR 108",
  m: "ALTCHAR 109",
  n: "ALTCHAR 110",
  o: "ALTCHAR 111",
  p: "ALTCHAR 112",
  q: "ALTCHAR 113",
  r: "ALTCHAR 114",
  s: "ALTCHAR 115",
  t: "ALTCHAR 116",
  u: "ALTCHAR 117",
  v: "ALTCHAR 118",
  w: "ALTCHAR 119",
  x: "ALTCHAR 120",
  y: "ALTCHAR 121",
  z: "ALTCHAR 122",

  "0": "ALTCHAR 48",
  "1": "ALTCHAR 49",
  "2": "ALTCHAR 50",
  "3": "ALTCHAR 51",
  "4": "ALTCHAR 52",
  "5": "ALTCHAR 53",
  "6": "ALTCHAR 54",
  "7": "ALTCHAR 55",
  "8": "ALTCHAR 56",
  "9": "ALTCHAR 57",

  " ": "ALTCHAR 32",
  "!": "ALTCHAR 33",
  '"': "ALTCHAR 34",
  "#": "ALTCHAR 35",
  $: "ALTCHAR 36",
  "%": "ALTCHAR 37",
  "&": "ALTCHAR 38",
  "'": "ALTCHAR 39",
  "(": "ALTCHAR 40",
  ")": "ALTCHAR 41",
  "*": "ALTCHAR 42",
  "+": "ALTCHAR 43",
  ",": "ALTCHAR 44",
  "-": "ALTCHAR 45",
  ".": "ALTCHAR 46",
  "/": "ALTCHAR 47",
  ":": "ALTCHAR 58",
  ";": "ALTCHAR 59",
  "<": "ALTCHAR 60",
  "=": "ALTCHAR 61",
  ">": "ALTCHAR 62",
  "?": "ALTCHAR 63",
  "@": "ALTCHAR 64",
  "[": "ALTCHAR 91",
  "\\": "ALTCHAR 92",
  "]": "ALTCHAR 93",
  "^": "ALTCHAR 94",
  _: "ALTCHAR 95",
  "`": "ALTCHAR 96",
  "{": "ALTCHAR 123",
  "|": "ALTCHAR 124",
  "}": "ALTCHAR 125",
  "~": "ALTCHAR 126",
};

function textToAltCodes(text: string, useAltCodes: boolean, defaultDelay: number = 10): string {
  if (!useAltCodes) {
    return `STRING ${text}`;
  }

  let result = "";
  for (const char of text) {
    if (ALT_CODE_MAP[char]) {
      result += ALT_CODE_MAP[char] + "\n";
    } else {
      result += `ALT ${char.charCodeAt(0)}\n`;
    }
  }
  return result.trim();
}

function compileNode(node: Node, defaultDelay: number = 10): string {
  switch (node.type) {
    case "command":
      return node.command || "REM Empty command";

    case "key_combination":
      const modifiers = node.modifiers.join(" ");
      const keys = node.keys.join(" ");
      if (!modifiers && !keys) {
        return "REM Empty key combination";
      }
      return modifiers ? `${modifiers} ${keys}` : keys;

    case "text_input":
      return node.text
        ? textToAltCodes(node.text, node.useAltCodes, defaultDelay)
        : "REM Empty text input";

    case "delay":
      return `DELAY ${node.duration || 0}`;

    case "loop":
      let loopContent = "";
      const iterations = node.iterations || 1;
      for (let i = 0; i < iterations; i++) {
        loopContent += `REM Loop iteration ${i + 1}\n`;
        for (const childNode of node.children) {
          loopContent += compileNode(childNode, defaultDelay) + "\n";
        }
      }
      return loopContent.trim() || "REM Empty loop";

    case "condition":
      const condition = node.condition || "empty condition";
      let condContent = `REM IF ${condition}\n`;
      for (const trueNode of node.trueNodes) {
        condContent += compileNode(trueNode, defaultDelay) + "\n";
      }
      if (node.falseNodes.length > 0) {
        condContent += `REM ELSE\n`;
        for (const falseNode of node.falseNodes) {
          condContent += compileNode(falseNode, defaultDelay) + "\n";
        }
      }
      condContent += `REM ENDIF`;
      return condContent;

    default:
      return `REM Unknown node type`;
  }
}

export function compileDuckyScript(script: DuckyScript, settings?: { defaultDelay: number; duckyVersion: number }): string {
  let output = "";
  const defaultDelay = settings?.defaultDelay || 10;
  const duckyVersion = settings?.duckyVersion || 3;

  // Add DEFAULT_DELAY statement at the top if defaultDelay is greater than 0
  if (defaultDelay > 19) {
    output += `DEFAULT_DELAY ${defaultDelay}\n`;
  }

  output += `REM DuckyScript generated by HID-F\n`;
  output += `REM Script: ${script.metadata.name}\n`;
  output += `REM Description: ${script.metadata.description}\n`;
  output += `REM Created: ${script.metadata.created}\n`;
  output += `REM Modified: ${script.metadata.modified}\n`;
  output += `REM Ducky Version: ${duckyVersion}.0\n`;
  output += `REM Default Delay: ${defaultDelay}ms\n\n`;

  const sortedNodes = topologicalSort(script.nodes, script.connections);

  for (const node of sortedNodes) {
    const compiled = compileNode(node, defaultDelay);
    output += compiled + "\n";
  }

  return output.trim();
}

function topologicalSort(nodes: Node[], connections: Connection[]): Node[] {
  const adjList = new Map<string, string[]>();
  const inDegree = new Map<string, number>();

  for (const node of nodes) {
    adjList.set(node.id, []);
    inDegree.set(node.id, 0);
  }

  for (const conn of connections) {
    adjList.get(conn.from)?.push(conn.to);
    inDegree.set(conn.to, (inDegree.get(conn.to) || 0) + 1);
  }

  const queue: string[] = [];
  for (const [nodeId, degree] of inDegree) {
    if (degree === 0) {
      queue.push(nodeId);
    }
  }

  const result: Node[] = [];
  const nodeMap = new Map(nodes.map((n) => [n.id, n]));

  while (queue.length > 0) {
    const nodeId = queue.shift()!;
    const node = nodeMap.get(nodeId);
    if (node) {
      result.push(node);
    }

    for (const neighbor of adjList.get(nodeId) || []) {
      inDegree.set(neighbor, (inDegree.get(neighbor) || 0) - 1);
      if (inDegree.get(neighbor) === 0) {
        queue.push(neighbor);
      }
    }
  }

  for (const node of nodes) {
    if (!result.find((n) => n.id === node.id)) {
      result.push(node);
    }
  }

  return result;
}

export interface ValidationError {
  message: string;
  severity: 'error' | 'warning';
  nodeIds?: string[];
}

export function validateScript(script: DuckyScript): ValidationError[] {
  const errors: ValidationError[] = [];

  if (script.nodes.length === 0) {
    errors.push({
      message: "No nodes found in script",
      severity: 'error'
    });
    return errors;
  }

  // Check for circular dependencies
  if (hasCycle(script.nodes, script.connections)) {
    errors.push({
      message: "Circular dependency detected in node connections",
      severity: 'error'
    });
  }

  // Check connection errors
  const connectionErrors = validateConnections(script.nodes, script.connections);
  errors.push(...connectionErrors);

  // Check individual node validation
  for (const node of script.nodes) {
    switch (node.type) {
      case "delay":
        if (node.duration < 0) {
          errors.push({
            message: `Delay node "${node.label}" has negative duration`,
            severity: 'error',
            nodeIds: [node.id]
          });
        }
        break;
      case "loop":
        if (node.iterations < 1) {
          errors.push({
            message: `Loop node "${node.label}" has invalid iteration count`,
            severity: 'error',
            nodeIds: [node.id]
          });
        }
        break;
      case "text_input":
        if (!node.text.trim()) {
          errors.push({
            message: `Text input node "${node.label}" is empty`,
            severity: 'warning',
            nodeIds: [node.id]
          });
        }
        break;
    }
  }

  return errors;
}

function validateConnections(nodes: Node[], connections: Connection[]): ValidationError[] {
  const errors: ValidationError[] = [];
  
  // Count incoming and outgoing connections for each node
  const incomingCount = new Map<string, number>();
  const outgoingCount = new Map<string, number>();
  
  // Initialize counts
  for (const node of nodes) {
    incomingCount.set(node.id, 0);
    outgoingCount.set(node.id, 0);
  }
  
  // Count connections
  for (const conn of connections) {
    const currentIncoming = incomingCount.get(conn.to) || 0;
    const currentOutgoing = outgoingCount.get(conn.from) || 0;
    incomingCount.set(conn.to, currentIncoming + 1);
    outgoingCount.set(conn.from, currentOutgoing + 1);
  }
  
  // Collect nodes with no connections
  const nodesWithNoConnections: Node[] = [];
  
  // Check for connection errors
  for (const node of nodes) {
    const incoming = incomingCount.get(node.id) || 0;
    const outgoing = outgoingCount.get(node.id) || 0;
    
    // Check for double incoming connections (except for condition nodes which can have multiple)
    if (incoming > 1 && node.type !== 'condition') {
      errors.push({
        message: `Node "${node.label}" has multiple incoming connections (${incoming})`,
        severity: 'error',
        nodeIds: [node.id]
      });
    }
    
    // Check for double outgoing connections (except for condition nodes which can have multiple)
    if (outgoing > 1 && node.type !== 'condition') {
      errors.push({
        message: `Node "${node.label}" has multiple outgoing connections (${outgoing})`,
        severity: 'error',
        nodeIds: [node.id]
      });
    }
    
    // Collect nodes with no connections for later processing
    if (incoming === 0 && outgoing === 0) {
      const hasOtherNodes = nodes.some(n => n.id !== node.id);
      if (hasOtherNodes) {
        nodesWithNoConnections.push(node);
      }
    }
  }
  
  // If there are multiple nodes with no connections, only highlight the most recent one
  if (nodesWithNoConnections.length > 1) {
    // Sort by creation order (assuming nodes are added in order, so later nodes have higher index)
    const sortedNodes = nodesWithNoConnections.sort((a, b) => {
      const indexA = nodes.findIndex(n => n.id === a.id);
      const indexB = nodes.findIndex(n => n.id === b.id);
      return indexB - indexA; // Most recent first
    });
    
    // Only highlight the most recent node with no connections
    const mostRecentNode = sortedNodes[0];
    errors.push({
      message: `Node "${mostRecentNode.label}" has no connections (multiple start nodes detected)`,
      severity: 'error',
      nodeIds: [mostRecentNode.id]
    });
  } else if (nodesWithNoConnections.length === 1) {
    // Only one node with no connections - this is normal for a start node
    // Don't add an error for this case
  }
  
  return errors;
}

function hasCycle(nodes: Node[], connections: Connection[]): boolean {
  const visited = new Set<string>();
  const recStack = new Set<string>();
  const adjList = new Map<string, string[]>();

  for (const node of nodes) {
    adjList.set(node.id, []);
  }
  for (const conn of connections) {
    adjList.get(conn.from)?.push(conn.to);
  }

  function dfs(nodeId: string): boolean {
    visited.add(nodeId);
    recStack.add(nodeId);

    for (const neighbor of adjList.get(nodeId) || []) {
      if (!visited.has(neighbor)) {
        if (dfs(neighbor)) return true;
      } else if (recStack.has(neighbor)) {
        return true;
      }
    }

    recStack.delete(nodeId);
    return false;
  }

  for (const node of nodes) {
    if (!visited.has(node.id)) {
      if (dfs(node.id)) return true;
    }
  }

  return false;
}
