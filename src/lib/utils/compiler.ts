import type { Node, Connection, DuckyScript } from "../types/nodes.js";

const ALT_CODE_MAP: Record<string, string> = {
  A: "ALTCHAR 65",
  B: "ALTCHAR 66",
  C: "ALTCHAR 67",
  D: "ALTCHAR 68",
  E: "ALTCHAR 69",
  F: "ALTCHAR 70",
  G: "ALTCHAR 71",
  H: "ALTCHAR 72",
  I: "ALTCHAR 73",
  J: "ALTCHAR 74",
  K: "ALTCHAR 75",
  L: "ALTCHAR 76",
  M: "ALTCHAR 77",
  N: "ALTCHAR 78",
  O: "ALTCHAR 79",
  P: "ALTCHAR 80",
  Q: "ALTCHAR 81",
  R: "ALTCHAR 82",
  S: "ALTCHAR 83",
  T: "ALTCHAR 84",
  U: "ALTCHAR 85",
  V: "ALTCHAR 86",
  W: "ALTCHAR 87",
  X: "ALTCHAR 88",
  Y: "ALTCHAR 89",
  Z: "ALTCHAR 90",

  a: "ALTCHAR 97",
  b: "ALTCHAR 98",
  c: "ALTCHAR 99",
  d: "ALTCHAR 100",
  e: "ALTCHAR 101",
  f: "ALTCHAR 102",
  g: "ALTCHAR 103",
  h: "ALTCHAR 104",
  i: "ALTCHAR 105",
  j: "ALTCHAR 106",
  k: "ALTCHAR 107",
  l: "ALTCHAR 108",
  m: "ALTCHAR 109",
  n: "ALTCHAR 110",
  o: "ALTCHAR 111",
  p: "ALTCHAR 112",
  q: "ALTCHAR 113",
  r: "ALTCHAR 114",
  s: "ALTCHAR 115",
  t: "ALTCHAR 116",
  u: "ALTCHAR 117",
  v: "ALTCHAR 118",
  w: "ALTCHAR 119",
  x: "ALTCHAR 120",
  y: "ALTCHAR 121",
  z: "ALTCHAR 122",

  "0": "ALTCHAR 48",
  "1": "ALTCHAR 49",
  "2": "ALTCHAR 50",
  "3": "ALTCHAR 51",
  "4": "ALTCHAR 52",
  "5": "ALTCHAR 53",
  "6": "ALTCHAR 54",
  "7": "ALTCHAR 55",
  "8": "ALTCHAR 56",
  "9": "ALTCHAR 57",

  " ": "ALTCHAR 32",
  "!": "ALTCHAR 33",
  '"': "ALTCHAR 34",
  "#": "ALTCHAR 35",
  $: "ALTCHAR 36",
  "%": "ALTCHAR 37",
  "&": "ALTCHAR 38",
  "'": "ALTCHAR 39",
  "(": "ALTCHAR 40",
  ")": "ALTCHAR 41",
  "*": "ALTCHAR 42",
  "+": "ALTCHAR 43",
  ",": "ALTCHAR 44",
  "-": "ALTCHAR 45",
  ".": "ALTCHAR 46",
  "/": "ALTCHAR 47",
  ":": "ALTCHAR 58",
  ";": "ALTCHAR 59",
  "<": "ALTCHAR 60",
  "=": "ALTCHAR 61",
  ">": "ALTCHAR 62",
  "?": "ALTCHAR 63",
  "@": "ALTCHAR 64",
  "[": "ALTCHAR 91",
  "\\": "ALTCHAR 92",
  "]": "ALTCHAR 93",
  "^": "ALTCHAR 94",
  _: "ALTCHAR 95",
  "`": "ALTCHAR 96",
  "{": "ALTCHAR 123",
  "|": "ALTCHAR 124",
  "}": "ALTCHAR 125",
  "~": "ALTCHAR 126",
};

function textToAltCodes(text: string, useAltCodes: boolean): string {
  if (!useAltCodes) {
    return `STRING ${text}\nDELAY 10`;
  }

  let result = "";
  for (const char of text) {
    if (ALT_CODE_MAP[char]) {
      result += ALT_CODE_MAP[char] + "\nDELAY 10\n";
    } else {
      result += `ALT ${char.charCodeAt(0)}\nDELAY 10\n`;
    }
  }
  return result.trim();
}

function compileNode(node: Node): string {
  switch (node.type) {
    case "command":
      return node.command || "REM Empty command";

    case "key_combination":
      const modifiers = node.modifiers.join(" ");
      const keys = node.keys.join(" ");
      if (!modifiers && !keys) {
        return "REM Empty key combination";
      }
      return modifiers ? `${modifiers} ${keys}` : keys;

    case "text_input":
      return node.text
        ? textToAltCodes(node.text, node.useAltCodes)
        : "REM Empty text input";

    case "delay":
      return `DELAY ${node.duration || 0}`;

    case "loop":
      let loopContent = "";
      const iterations = node.iterations || 1;
      for (let i = 0; i < iterations; i++) {
        loopContent += `REM Loop iteration ${i + 1}\n`;
        for (const childNode of node.children) {
          loopContent += compileNode(childNode) + "\n";
        }
      }
      return loopContent.trim() || "REM Empty loop";

    case "condition":
      const condition = node.condition || "empty condition";
      let condContent = `REM IF ${condition}\n`;
      for (const trueNode of node.trueNodes) {
        condContent += compileNode(trueNode) + "\n";
      }
      if (node.falseNodes.length > 0) {
        condContent += `REM ELSE\n`;
        for (const falseNode of node.falseNodes) {
          condContent += compileNode(falseNode) + "\n";
        }
      }
      condContent += `REM ENDIF`;
      return condContent;

    default:
      return `REM Unknown node type`;
  }
}

export function compileDuckyScript(script: DuckyScript): string {
  let output = "";

  output += `REM DuckyScript generated by HID-F\n`;
  output += `REM Script: ${script.metadata.name}\n`;
  output += `REM Description: ${script.metadata.description}\n`;
  output += `REM Created: ${script.metadata.created}\n`;
  output += `REM Modified: ${script.metadata.modified}\n\n`;

  const sortedNodes = topologicalSort(script.nodes, script.connections);

  for (const node of sortedNodes) {
    const compiled = compileNode(node);
    output += compiled + "\n";
  }

  return output.trim();
}

function topologicalSort(nodes: Node[], connections: Connection[]): Node[] {
  const adjList = new Map<string, string[]>();
  const inDegree = new Map<string, number>();

  for (const node of nodes) {
    adjList.set(node.id, []);
    inDegree.set(node.id, 0);
  }

  for (const conn of connections) {
    adjList.get(conn.from)?.push(conn.to);
    inDegree.set(conn.to, (inDegree.get(conn.to) || 0) + 1);
  }

  const queue: string[] = [];
  for (const [nodeId, degree] of inDegree) {
    if (degree === 0) {
      queue.push(nodeId);
    }
  }

  const result: Node[] = [];
  const nodeMap = new Map(nodes.map((n) => [n.id, n]));

  while (queue.length > 0) {
    const nodeId = queue.shift()!;
    const node = nodeMap.get(nodeId);
    if (node) {
      result.push(node);
    }

    for (const neighbor of adjList.get(nodeId) || []) {
      inDegree.set(neighbor, (inDegree.get(neighbor) || 0) - 1);
      if (inDegree.get(neighbor) === 0) {
        queue.push(neighbor);
      }
    }
  }

  for (const node of nodes) {
    if (!result.find((n) => n.id === node.id)) {
      result.push(node);
    }
  }

  return result;
}

export function validateScript(script: DuckyScript): string[] {
  const errors: string[] = [];

  if (hasCycle(script.nodes, script.connections)) {
    errors.push("Circular dependency detected in node connections");
  }

  for (const node of script.nodes) {
    switch (node.type) {
      case "delay":
        if (node.duration < 0) {
          errors.push(`Delay node "${node.label}" has negative duration`);
        }
        break;
      case "loop":
        if (node.iterations < 1) {
          errors.push(`Loop node "${node.label}" has invalid iteration count`);
        }
        break;
      case "text_input":
        if (!node.text.trim()) {
          errors.push(`Text input node "${node.label}" is empty`);
        }
        break;
    }
  }

  return errors;
}

function hasCycle(nodes: Node[], connections: Connection[]): boolean {
  const visited = new Set<string>();
  const recStack = new Set<string>();
  const adjList = new Map<string, string[]>();

  for (const node of nodes) {
    adjList.set(node.id, []);
  }
  for (const conn of connections) {
    adjList.get(conn.from)?.push(conn.to);
  }

  function dfs(nodeId: string): boolean {
    visited.add(nodeId);
    recStack.add(nodeId);

    for (const neighbor of adjList.get(nodeId) || []) {
      if (!visited.has(neighbor)) {
        if (dfs(neighbor)) return true;
      } else if (recStack.has(neighbor)) {
        return true;
      }
    }

    recStack.delete(nodeId);
    return false;
  }

  for (const node of nodes) {
    if (!visited.has(node.id)) {
      if (dfs(node.id)) return true;
    }
  }

  return false;
}
